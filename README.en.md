<!-- markdownlint-disable -->
<div align="center">

# STM32 Project Template

Template for projects with STM32 microcontrollers using STM32CubeMX and CMake

</div>

<div align="center">
  <a href="https://cplusplus.com/"><img alt="Made with C++" src="https://img.shields.io/badge/made_with-c%2B%2B-blue?style=for-the-badge&labelColor=ef4041&color=c1282d" height="30"></a>
  <a href="https://www.st.com/en/development-tools/stm32cubemx.html"><img alt="Uses STM32CubeMX" src="https://img.shields.io/badge/uses-stm32cubemx-blue?style=for-the-badge&labelColor=38c1d0&color=45a4b8" height="30"></a>
  <a href="https://en.wikipedia.org/wiki/Embedded_system"><img alt="For Embedded Systems" src="https://img.shields.io/badge/for-embedded_systems-blue?style=for-the-badge&labelColor=adec37&color=27a744" height="30"></a>
  <a href="LICENSE"><img alt="MIT License" src="https://img.shields.io/badge/license-MIT-blue?style=for-the-badge&labelColor=ef4041&color=c1282d" height="30"></a>
  <a href="README.md"><img alt="Leia em português" src="https://img.shields.io/badge/Leia%20em-Português-blue?style=for-the-badge&labelColor=555555&color=007ec6" height="30"></a>
</div>
<!-- markdownlint-restore -->

## 📑 Table of Contents

- [📑 Table of Contents](#-table-of-contents)
- [📁 Folder Structure](#-folder-structure)
- [🛠 Configuration](#-configuration)
  - [Dependencies](#dependencies)
  - [1. CubeMX Project](#1-cubemx-project)
  - [2. CMakeLists.txt](#2-cmakeliststxt)
- [🔨 Compilation](#-compilation)
- [🚀 Execution](#-execution)
- [🧪 Tests](#-tests)
- [🐛 Debugging](#-debugging)
- [💄 Code Style](#-code-style)
  - [🎨 Formatting](#-formatting)
  - [🚨 Linter](#-linter)
- [📦 Submodules](#-submodules)
- [🐋 Docker](#-docker)
- [📝 Documentation](#-documentation)
- [🛠️ Windows Development Environment (WSL)](#️-windows-development-environment-wsl)
- [👥 Contribution Guidelines](#-contribution-guidelines)
  - [💬 Git Commit Messages](#-git-commit-messages)
  - [🔀 GitHub Flow](#-github-flow)
- [🙌 Acknowledgements](#-acknowledgements)

## 📁 Folder Structure

- **.docker/** - Docker configurations and scripts
- **.github/** - GitHub Actions configurations
- **.vscode/** - Visual Studio Code configurations
- **cmake/** - Custom functions for CMake
- **config/** - Project configurations
- **cube/** - STM32CubeMX project (.ioc and generated files)
- **include/** - Header files
- **lib/** - Submodules and external libraries
- **src/** - Main application source code
- **test/** - Tests

Additionally, the following folders contain generated files and are not versioned:

- **build/** - Files generated during compilation
- **docs/** - Generated documentation

## 🛠 Configuration

### Dependencies

To make the most of this template, from basic compilation to debugging and flashing, some tools are essential and others are optional, depending on your workflow. Below we describe the main ones, with example commands for installation on Debian/Ubuntu systems (like Ubuntu, Mint). If you use another Linux distribution (Fedora, Arch) or macOS, adapt the commands for your package manager (`dnf`, `pacman`, `brew`, etc.).

#### Essential to Start

You will need these tools just to clone and compile the project:

*   **`git`**: The fundamental version control system for downloading this template, managing your changes, and handling any external libraries included as submodules.
    ```bash
    sudo apt install git
    ```
*   **`cmake`**: The heart of the build system. It interprets the instructions in the `CMakeLists.txt` file and generates the necessary files (Makefiles) for compilation to occur in your specific environment.
    ```bash
    sudo apt install cmake
    ```
*   **`make`**: This tool reads the Makefiles generated by CMake and executes the compilation commands in the correct order. It's what you usually invoke to compile (`make -j`).
    ```bash
    sudo apt install make
    ```
*   **`gcc-arm-none-eabi` Toolchain**: This is the set of cross-compilation tools (C/C++ compiler, linker, etc.) that transforms your source code into executable binary code for STM32 microcontrollers (based on ARM Cortex-M).
    ```bash
    sudo apt install gcc-arm-none-eabi
    ```
*   **`STM32CubeMX`**: To visually configure your STM32 peripherals, clock system, and generate the base initialization code (including the `.ioc` file), you will need this graphical tool from ST. Download the installer directly from the [STMicroelectronics website](https://www.st.com/en/development-tools/stm32cubemx.html). For CMake to interact with it (useful for generating code), ensure the executable is in your system's `PATH` or that the `CUBE_CMD` environment variable points to it. *(Manual installation via download)*.

> [!WARNING]
> Currently, this template does not support CubeMX versions above 6.13.

*   **`STM32CubeProgrammer`**: Essential for flashing the compiled firmware onto your microcontroller using an ST-LINK programmer. It is required to use the `make flash` command. Download the installer from the [STMicroelectronics website](https://www.st.com/en/development-tools/stm32cubeprog.html) and ensure the command-line executable (`STM32_Programmer_CLI`) is in your `PATH`. *(Manual installation via download)*.

#### Additional Tools for Extra Features

These tools enable features such as graphical configuration, flashing, advanced debugging, code standardization, and documentation. Install the ones relevant to you:

*   **`Segger J-Link Software`**: If you use a J-Link programmer/debugger, you will need Segger's software package. It provides the necessary drivers and the GDB server (`JLinkGDBServer`) for debugging and for the `make jflash` command. Get the "J-Link Software and Documentation Pack" from the [Segger website](https://www.segger.com/downloads/jlink/). The GDB server needs to be accessible (via `PATH` or the `JLINK_CMD` variable). *(Manual installation via download)*.
*   **`openocd`**: A popular open-source alternative as a debug server (GDB Server). The Open On-Chip Debugger supports various adapters, including ST-LINK, and is one of the options configured for debugging in this template.
    ```bash
    sudo apt install openocd
    ```
*   **`stlink-tools`**: A set of command-line tools specific to ST-LINK adapters. Includes `st-flash` for flashing and `st-util` which can act as a simple GDB server, being another option for debugging.
    ```bash
    sudo apt install stlink-tools
    ```
*   **`gdb-multiarch`**: The GNU Debugger client, capable of understanding multiple architectures like ARM. This is what you use to connect to GDB servers (JLinkGDBServer, OpenOCD, st-util) and control program execution step-by-step, inspect variables, etc. Often installed alongside the `gcc-arm-none-eabi` toolchain, but otherwise, install with:
    ```bash
    sudo apt install gdb-multiarch
    ```
*   **`clang-format`**: To keep the code consistently and automatically formatted, we use `clang-format`. It applies the rules defined in the `.clang-format` file to your code when you run `make format`.
    ```bash
    sudo apt install clang-format
    ```
*   **`clang-tidy`**: A static analysis tool (linter) that helps identify potential problems, bugs, and deviations from good practices in C/C++ code. It uses the rules from the `.clang-tidy` file and runs during compilation if you configure CMake with `-DLINTER_MODE=ON` or `-DLINTER_MODE=FIX`.
    ```bash
    sudo apt install clang-tidy
    ```
*   **`doxygen` & Co.**: To automatically generate documentation from comments in the code, we use `doxygen`. To generate diagrams (like call graphs), it can use `graphviz`. And if you want the documentation also in PDF, it uses `LaTeX` (provided by `texlive`). Run `make docs` to generate the documentation. Install the necessary tools with:
    ```bash
    sudo apt install doxygen graphviz texlive-latex-extra texlive-fonts-extra
    ```
    *(Note that the `texlive` installation can take up considerable disk space).*

> [!TIP]
> Remember to consult the specific sections of this README (Compilation, Execution, Debugging, Code Style, Documentation) to better understand how and when each of these optional tools comes into play in the workflow provided by the template.

### 1. CubeMX Project

Starting an STM32 project is done in STM32CubeMX. For this, you need to install [STM32CubeMX](https://www.st.com/en/development-tools/stm32cubemx.html) and configure the project:

> [!IMPORTANT]
> For CMake to find and use STM32CubeMX automatically (e.g., when generating code), ensure that the CubeMX executable is in your system's `PATH` or set the `CUBE_CMD` environment variable with the full path to the executable.

1. Create a new project in the `cube/` folder
2. Settings:
    - **Project Manager > Project > Application Structure:** Basic
    - **Project Manager > Project > Toolchain/IDE:** CMake
    - **Project Manager > Code Generator > Generate peripheral initialization:** Pair of .c/.h files per peripheral
    - **Project Manager > Code Generator > Delete previous generated files when not regenerated:** Enabled

### 2. CMakeLists.txt

Edit the main `CMakeLists.txt` file with your project information:

```cmake
# Project name (same as the .ioc file without extension)
set(CMAKE_PROJECT_NAME my_project)

# Board version (optional)
set(BOARD_VERSION "")
```

## 🔨 Compilation

Before compiling for the first time, make sure Git submodules (if any) have been initialized:

```bash
git submodule update --init --recursive
```

Now, create a `build/` folder in the project root (if it doesn't exist yet) and enter it:

```bash
mkdir -p build
cd build
```

Inside it, configure the environment with CMake:

```bash
cmake ..
```

Then, compile the project:

```bash
make -j
```

> The `-j` parameter enables parallel compilation, using more of your processor cores to speed up the process.

### Clean files

```bash
make clear       # User code
make clear_cube  # Cube libraries
make clear_all   # Everything
```

### Manual

To get a complete list of available `make` commands (defined in CMake), use:

```bash
make helpme
```

## 🚀 Execution

To flash the main firmware onto the microcontroller, you can use one of the following commands (requires the corresponding tool to be installed):

### Flashing via [STM32CubeProgrammer](https://www.st.com/en/development-tools/stm32cubeprog.html)

> [!IMPORTANT]
> The `STM32_Programmer_CLI` executable needs to be in your system's `PATH` for this command to work.

```bash
make flash
```

### Flashing via J-Link

> [!IMPORTANT]
> `JLinkExe` needs to be in your `PATH`, or the `JLINK_CMD` environment variable needs to be set with the path to the executable.

```bash
make jflash
```

If the project hasn't been compiled yet, these commands will automatically compile it before flashing.

## 🧪 Tests

Each test should be an independent file in the `test/` folder with its own `main()` function.

To compile a specific test, use `make <test_name>`. For example, to compile the test `test/test_gpio.c`:

```bash
make test_gpio -j
```

To flash a specific test, use `make flash_<test_name>` or `make jflash_<test_name>`:

```bash
make flash_test_gpio
```

or

```bash
make jflash_test_gpio
```

To compile all tests defined in the project, use `make test_all`:

```bash
make test_all -j
```

## 🐛 Debugging

1.  **Configure the build for Debug:**
    Run CMake with the `BUILD_TYPE` variable set to `Debug` (includes debug symbols, no optimizations) or `RelWithDebInfo` (includes symbols, with optimizations).

    ```bash
    # Inside the build/ folder
    cmake .. -DBUILD_TYPE=Debug
    ```

    or

    ```bash
    cmake .. -DBUILD_TYPE=RelWithDebInfo
    ```

2.  **Compile the project:**

    ```bash
    make -j
    ```

3.  **Generate debug configurations (Optional, for VS Code):**
    If you are using VS Code with the Cortex-Debug extension, generate the `launch.json` configuration files:

    ```bash
    make debug # For the main executable
    ```

    To generate configurations for a specific test:

    ```bash
    make debug_test_gpio
    ```

4.  **Start the Debug Session:**
    Use the [Cortex-Debug](https://marketplace.visualstudio.com/items?marus25.Cortex-Debug) extension in VS Code with one of the configurations generated in the previous step, or manually start a GDB server and connect with `gdb-multiarch`. The default configurations use one of the following GDB servers (install the one you will use):

    *   **[J-Link](https://www.segger.com/downloads/jlink/):** You might need to flash the firmware beforehand with `make jflash` or `make jflash_my_test`.
    *   **[OpenOCD](https://openocd.org/):** `sudo apt install openocd` (Ubuntu/Debian)
    *   **[ST-Util](https://github.com/stlink-org/stlink):** `sudo apt install stlink-tools` (Ubuntu/Debian)

## 💄 Code Style

To maintain code consistency and quality, we use formatting and linting tools.

### 🎨 Formatting

We use `clang-format` to standardize the formatting of C/C++ code. The style rules are defined in the `.clang-format` file in the project root.

To format all source code (`src/`, `include/`, `test/`) according to the rules, run in the `build/` folder:

```bash
make format
```

### 🚨 Linter

We use `clang-tidy` for static analysis, helping to identify potential bugs, enforce good practices, and ensure adherence to coding standards. The linting rules are defined in the `.clang-tidy` file in the project root.

The linter runs during compilation when the CMake variable `LINTER_MODE` is enabled. Configure CMake (inside the `build/` folder) with one of the following options:

*   **Enable Linter (analysis only):**
    ```bash
    cmake .. -DLINTER_MODE=ON
    ```
*   **Enable Linter and apply automatic fixes:**
    ```bash
    cmake .. -DLINTER_MODE=FIX
    ```
*   **Disable Linter (default):**
    ```bash
    cmake .. -DLINTER_MODE=OFF
    ```

After configuring CMake, compile the project normally to run the linter (if enabled):

```bash
make -j
```

## 📦 Submodules

To add an external library as a Git submodule in the `lib/` folder:

```bash
git submodule add --name <descriptive_name> <repository_url> lib/<folder_name>
# Example:
# git submodule add --name lib_cmsis_dsp git@github.com:ARM-software/CMSIS-DSP.git lib/cmsis_dsp
```

To clone a project that uses submodules for the first time, or to update existing submodules:

```bash
git submodule update --init --recursive
```

## 🐋 Docker

It is possible to use Docker to create a containerized development and compilation environment, ensuring consistency across different machines and facilitating continuous integration (CI/CD). You need to have [Docker](https://docs.docker.com/get-docker/) and [Docker Compose](https://docs.docker.com/compose/install/) installed.

The base Docker configuration for this template can be found at https://github.com/ThundeRatz/stm32cubemx_docker. Adapt the files in `.docker/` as needed for your project.

### Compile using container

Run the compilation directly from outside the container:

```bash
docker compose run build # Compiles the main project
docker compose run format # Formats the code
docker compose run lint   # Runs the linter (requires LINTER_MODE=ON in build)
```

### Interactive development environment

To enter a shell inside the container and execute commands manually:

```bash
docker compose run dev
```

And once inside the container, you can use the normal commands:

```bash
mkdir -p build
cd build
cmake ..
make -j
```

> [!TIP]
> If you use Visual Studio Code, the [Dev Containers](https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-containers) extension allows you to open the project directly *inside* the container defined in `docker-compose.yml`, providing an integrated development experience.

## 📝 Documentation

This template is configured to generate source code documentation using [Doxygen](https://www.doxygen.nl/).

To generate the documentation (HTML and PDF, if LaTeX is installed) in the `docs/` folder, run the following command inside the `build/` folder:

```bash
make docs
```

The Doxygen configuration is controlled by the `Doxyfile` file in the project root. Edit it to customize the documentation generation.

## 🛠️ Windows Development Environment (WSL)

If you are developing on a Windows machine using the [**Windows Subsystem for Linux (WSL)**](https://learn.microsoft.com/en-us/windows/wsl/), we recommend the following workflow for a better experience:

1.  **Install Build/Code Tools in WSL:**
    *   `cmake`, `make`, `gcc-arm-none-eabi`, `git`, `clang-format`, `clang-tidy`, `doxygen`, etc. (using your Linux distribution's package manager, like `apt`), as described in the [Dependencies section](#dependencies).
2.  **Install Hardware/Interface Tools on Windows:**
    *   [STM32CubeMX](https://www.st.com/en/development-tools/stm32cubemx.html)
    *   [STM32CubeProgrammer](https://www.st.com/en/development-tools/stm32cubeprog.html)
    *   Drivers and Software for your Debugger (e.g., [J-Link Software and Documentation Pack](https://www.segger.com/downloads/jlink/), ST-LINK Drivers).
3.  **Add Windows Tools to PATH:**
    This makes it easier to call `STM32_Programmer_CLI.exe` or `JLinkGDBServerCL.exe` directly from the WSL terminal. Since WSL automatically imports the Windows PATH, edit your Windows PATH to include the installation directories of the tools.
4.  **Recommended Workflow:**
    *   Use the WSL terminal to clone, compile (`cmake`, `make`), format (`make format`), etc.
    *   Run STM32CubeMX on Windows to configure hardware and generate code (CMake can detect it via PATH).
    *   Use the `make flash` or `make jflash` commands in WSL (they will call the Windows tools via PATH).
    *   For debugging, run the appropriate GDB Server (e.g., `JLinkGDBServerCL.exe`, `openocd.exe`, `st-util`) on **Windows** and connect to it from `gdb-multiarch` in WSL or via VS Code (see note below).

> [!NOTE]
> **WSL Networking for Debugging:** When running a GDB Server on Windows (port `localhost:XXXX`), for GDB inside WSL to connect to it, you might need to configure [**Mirrored mode networking**](https://learn.microsoft.com/en-us/windows/wsl/networking#mirrored-mode-networking) in WSL (requires recent Windows 11 builds). This makes WSL share the same IP address as Windows, facilitating localhost communication.

**Alternatives:**
*   You can define the `JLINK_CMD` and `PROGRAMMER_CMD` environment variables in CMake or the WSL environment to explicitly point to the executables on Windows (`/mnt/c/...`), if you don't want to add them to the PATH.
*   It is possible to install and use tools like OpenOCD or stlink-tools directly in WSL and try to pass the USB device to WSL using `usbipd-win`. Consult the [official WSL documentation on USB](https://learn.microsoft.com/en-us/windows/wsl/connect-usb) for more details, but this approach might be less stable than using the native Windows tools.

## 👥 Contribution Guidelines

To contribute to this project (or projects derived from this template), please follow these guidelines:

### 💬 Git Commit Messages

To maintain a clear, consistent, and globally understandable history, commit messages **must be written in English**. Follow these guidelines when writing your messages:

1.  **Use the Present Tense and Imperative Mood:**
    *   Describe what the commit *does*, as if giving an order.
    *   Example: Write `✨ Add user profile feature` instead of `Added user profile feature` or `Adds user profile feature`.

2.  **Start with a Descriptive Emoji:**
    *   An emoji at the beginning of the subject line helps quickly identify the type of change.
    *   Common examples (Emoji `code`: Example Message - *Context/Meaning*):
        *   `🐛 Fix issue with timer interrupt` - *Fixes a problem with the timer interrupt*
        *   `✨ Implement SPI communication module` - *Implements the SPI communication module*
        *   `📝 Update README with setup instructions` - *Updates the README with setup instructions*
        *   `🎨 Format code using clang-format` - *Formats code using clang-format*
        *   `⚡ Optimize ADC reading loop` - *Optimizes the ADC reading loop*
        *   `♻️  Refactor GPIO initialization logic` - *Refactors the GPIO initialization logic*
        *   `🔧 Adjust CMake toolchain file` - *Adjusts the CMake toolchain file*
        *   `🧪 Add unit tests for calculation function` - *Adds unit tests for the calculation function*
        *   `⬆️  Update HAL library to version 1.8.0` - *Updates HAL library to version 1.8.0*
        *   `⬇️  Downgrade external library due to bug` - *Downgrades an external library due to a bug*
        *   `🚑 Hotfix critical issue in motor control` - *Applies an urgent fix for a critical issue in motor control*
    *   For more emoji suggestions, see: [Gitmoji](https://gitmoji.dev/)

3.  **Keep the Subject Line Concise:**
    *   The first line (subject) should be a direct summary of the change, ideally 50-72 characters long.
    *   If more detail is needed, leave a blank line after the subject and write an explanatory body.

Following these conventions makes the Git history easier to navigate and understand for all contributors.

### 🔀 GitHub Flow

1.  **Follow [GitHub Flow](https://docs.github.com/en/get-started/quickstart/github-flow):**
    *   Create a branch from `develop` for each new feature or fix (`git checkout -b feature-name`).
    *   Make atomic and descriptive commits on your branch.
    *   Open a Pull Request (PR) when the work is ready for review.
    *   Discuss and review the code in the PR. Make changes as necessary.
    *   After approval and CI checks pass, merge the PR into `develop`.
2.  **Maintain code and documentation cohesion:** Ensure that new code integrates well with the existing codebase and that documentation (comments, README, Doxygen) is updated as needed.
3.  **Test your changes:** Before submitting a Pull Request, compile and test your modifications locally. If there are automated tests, ensure they pass.

## 🙌 Acknowledgements

This project would not have been possible without the support and collaboration of the entire **ThundeRatz** team.
The architectural and organizational decisions were heavily based on the best practices adopted in the team's projects, ensuring more modular, efficient, and scalable code.

We would also like to acknowledge the **[Micras](https://github.com/Team-Micras/MicrasFirmware)** project, whose development served as a basis for several decisions adopted here.
The technical discussions and challenges faced in Micras helped shape the structure and best practices of this template.
